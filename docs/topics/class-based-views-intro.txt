=================
Class-based views
=================

.. versionadded:: 1.3

.. note::
    Class-based views provide an alternative way to structure view code logic
    as Python objects instead of functions. They do not replace function-based
    views.

Class-based views have certain differences and advantages when compared to
function-based views:

    * Organization of code related to specific HTTP methods (get, post, etc)
      can be done with separate functions instead of conditional branching
      logic.
    * Object oriented techniques such as mixins (multiple inheritance) can be
      used to factor code more efficiently into reusable components.

The relationship and history of generic views, class-based views, and class-based generic views
-----------------------------------------------------------------------------------------------

In the beginning there were only view functions, early on it was recognized
that there were common idioms and patterns found in view development and
function-based generic views were introduced in Django X.X to abstract these
and ease view development.

The problem with function-based generic views is that while they covered the
simple cases well, there was no way to extend or customize them beyond some
simple configuration options, limiting their usefulness in many real-world
applications.

Class-based generic views have the same objective as function-based generic
views, to make view development easier. However, the way the solution is
implemented, through the use of mixins, provides a toolkit that results in
class-based generic views being more extensible and flexible than their
function-based counterparts.

This means that if you have tried function based generic views in the past and
found them lacking, you should not think of class-based generic views as
simply a class-based equivelant, but more of a clean break and fresh approach
to solving the original problems that generic views, in general, try to
solve.

The toolkit of base classes and mixins that Django uses to build
class-based generic views are built for maximum flexibility, and have such have
many hooks in the form of default method implementations and attributes that
you are unlikely to be concerned with. For example instead of limiting you to
a class based attribute for a form_class, the implementation uses a get_form
method, which calls a get_form_class method, which in its default
implementation just returns the form_class attribute of the class. These steps
seem to add hollow complexity to the classes, but without them, more advanced
designs would be limited.

Using class-based views
-----------------------

Class based views allow you to separate the code that responds to different
HTTP methods into different methods in a class instead as conditionally
branching code inside a single function.

So where the code to handle HTTP GET in a view function would look something like::

    def my_view(request):
        if request.method == 'GET':
            <view logic>
            return <Response>

in a class-based view would become::

    from django.views.base import View

    class MyView(View):

        greeting = "Good Day"

        def get(request):
            <view logic>
            return <Response>

Because Django's URL resolver expects to send the request and associated arguments
to a callable function, not a class, all class-based views have an "as_view"
class method which serves as the callable entry point to your class. The "as_view"
entry point then simply hands the request to a dispatcher method which checks to see
if the the class-based view has a method that matches the HTTP method of the
request.::

    # urls.py
    from django.conf.urls.defaults import *
    from some_app.views import MyView

    urlpatterns = patterns('',
        (r'^about/', MyView.as_view()),
    )


It is worth noting that what your method returns is
identical to what you return from a function-based view, namely some form of
HTTPResponse. This means that http shortcuts
(https://docs.djangoproject.com/en/1.3/topics/http/shortcuts/) are valid to use
inside a class-based view.

While a minimal class-based view does not require any class attributes to
perform its job, class attributes are useful in any class-based design approach
and there are two ways to configure class attributes.

The first is the standard Python way of subclassing and overriding attributes
and methods in the subclass. So that if your parent class had an attribute::


    from django.views.base import View

    class MyView(View):

        greeting = "Good Day"

        def get(request):
            <view logic>
            return <Response>

You can override that in a subclass::

    class MyOtherView(MyView):
        greeting = "Morning to ya"

Another approach is to configure class attributes
as keyword arguments to the as_view call in the URLconf.::

    urlpatterns = patterns('',
        (r'^about/', MyView.as_view(greeting="G'day")),
    )

.. note::
    While your class is instantiated for each request dispatched to it, class
    attributes set through the ``as_view`` entry point are configured only once
    at the time your URLs are imported.

Using mixins
------------

Mixins are a form of multiple inheritence, where behaviors and attributes of
multiple parent classes can be combined.

For example, in the generic class-based views, there is a mixin called
TemplateResponseMixin whose primary purpose is to define the method
render_to_response. When combined with the behavior of the View base class, you
have a class that will dispatch requests to the right methods, and has a render
to response method that uses a "template_name" and returns a TemplateResponse.

Mixins are an excellent way of reusing code across multiple classes, but they come
with some cost. The more your code is scattered among mixins, the harder it
will be to read a child class and know what exactly it is doing, and the harder
it will be to know which methods from which mixins to override if you are using
someone elses mixins.

Handling forms with class-based views
-------------------------------------

A basic function-based view that handles forms may look something like this::

    def myview(request):

        if request.method == "POST":
            form = MyForm(initial={'key':value}, data=request.POST)
            if form.is_valid():
                <process form cleaned data>
                return HttpResponseRedirect(...)
        else:
            form = MyForm()

        return render(...)

a class-based view to handle forms might look like::

    class MyFormView(View):

        form_class = MyDjangoForm
        initial = {}

        def get(self, request, *args, **kwargs):
            form = self.form_class(initial=self.initial)
            return render(...)

        def post(self, request, *args, **kwargs)
            form = self.form_class(initial=self.initial, data=self.request.POST)
            if form.is_valid():
                <process form cleaned data>
                return HttpResponseRedirect(...)

This is a very simple case, but you can see that you would then have the option
of passing in a form_class via URLconf configuration, or subclassing and only
overriding the post method.



Decorating class-based views
============================

.. highlightlang:: python

The extension of class-based views isn't limited to using mixins. You
can use also use decorators.

Decorating in URLconf
---------------------

The simplest way of decorating class-based views is to decorate the
result of the :meth:`~django.views.generic.base.View.as_view` method.
The easiest place to do this is in the URLconf where you deploy your
view::

    from django.contrib.auth.decorators import login_required, permission_required
    from django.views.generic import TemplateView

    from .views import VoteView

    urlpatterns = patterns('',
        (r'^about/', login_required(TemplateView.as_view(template_name="secret.html"))),
        (r'^vote/', permission_required('polls.can_vote')(VoteView.as_view())),
    )

This approach applies the decorator on a per-instance basis. If you
want every instance of a view to be decorated, you need to take a
different approach.

Decorating the class
--------------------

To decorate every instance of a class-based view, you need to decorate
the class definition itself. To do this you apply the decorator to the
:meth:`~django.views.generic.base.View.dispatch` method of the class.

A method on a class isn't quite the same as a standalone function, so
you can't just apply a function decorator to the method -- you need to
transform it into a method decorator first. The ``method_decorator``
decorator transforms a function decorator into a method decorator so
that it can be used on an instance method. For example::

    from django.contrib.auth.decorators import login_required
    from django.utils.decorators import method_decorator
    from django.views.generic import TemplateView

    class ProtectedView(TemplateView):
        template_name = 'secret.html'

        @method_decorator(login_required)
        def dispatch(self, *args, **kwargs):
            return super(ProtectedView, self).dispatch(*args, **kwargs)

In this example, every instance of ``ProtectedView`` will have
login protection.

.. note::

    ``method_decorator`` passes ``*args`` and ``**kwargs``
    as parameters to the decorated method on the class. If your method
    does not accept a compatible set of parameters it will raise a
    ``TypeError`` exception.

So if an HTTP GET request
class will be instantiated for each request
params passed in URLs will persist
class-based views named as normal?
decorating class-based views
shortcuts
rename Generic Views Doc to "function-based generic views"

